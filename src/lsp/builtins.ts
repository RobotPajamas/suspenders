/**
 * A Typescript/VSCode port of the utils/generate-builtins concept that will need to be built into Pants eventually
 * Instead of creating a PR and waiting for that to be released first (which would limit LSP functionality to probably 2.23+),
 * makes sense to hack together a quick TS version and use this as a backport
 */

import { AllHelpInfo, BuildFileSymbolHelpInfo, TargetTypeHelpInfo } from "../pants";

/**
 * From the `pants help-all` JSON string, create the file content for a `__builtins__.pyi` stub for pyright
 * This module does not perform I/O operations
 *
 * @param help_json The output of `pants help-all`
 * @returns `__builtins__.pyi` file content
 */
export function generateBuiltins(help_json: string): string {
  const helpInfo: AllHelpInfo = JSON.parse(help_json);

  const stubs: string[] = [];
  for (const [k, v] of Object.entries(helpInfo.name_to_target_type_info)) {
    stubs.push(makeFunctionStub(v));
  }
  for (const [k, v] of Object.entries(helpInfo.name_to_build_file_info)) {
    // the Targets should already be captured by the `name_to_target_type`
    if (v.is_target == false) {
      stubs.push(makeBuildStub(v));
    }
  }

  return FILE_TEMPLATE.replace("{functions}", stubs.join("\n\n"));
}

// TODO: Note that there isn't as much BuildFile information, so stubs gonna be stubby
// Example:
// "python_artifact": {
//   "documentation": "Represents a Python setup.py-based project.",
//   "is_target": false,
//   "name": "python_artifact",
//   "signature": "(**kwargs) -> None"
// },
function makeBuildStub(b: BuildFileSymbolHelpInfo): string {
  if (b.name === "python_artifact" || b.name === "setup_py") {
    b.signature = b.signature?.replace("None", "PythonArtifact");
  }

  return `def ${b.name}${b.signature}:
    """
    ${b.documentation}
    """`;
}

function makeFunctionStub(t: TargetTypeHelpInfo): string {
  const parameters: string[] = [];
  const parameterDescriptions: string[] = [];

  // Sort the fields into Python-safe order (defaults last)
  const fields = [...t.fields].sort((a, b) =>
    a.required === b.required ? 0 : a.required ? -1 : 1
  );
  fields.unshift({
    alias: "name",
    default: undefined,
    description: "The name of the target.",
    provider: "",
    required: true,
    type_hint: "str",
  });

  // Perform parameter-level replacements
  for (const f of fields) {
    const maybe_default = f.required ? "" : ` = ${f.default}`.replace("null", "None");
    parameters.push(`${f.alias}: ${f.type_hint}${maybe_default}`);
    parameterDescriptions.push(`:param ${f.alias}: ${f.description}`);
  }

  // Perform function-level replacement
  return `def ${t.alias}(\n    ${parameters.join(",\n    ")}\n) -> None:
    """
    ${t.summary}

    ${t.description}

    ${parameterDescriptions.join("\n    ")}
    """`;
}

const FILE_TEMPLATE: string = `# This file is generated by suspenders/lsp/builtins.ts as a backport of an upcoming Pants-native feature

from __future__ import annotations

from collections.abc import Iterable
from typing import Any, Dict, Tuple, Union

# Not quite accurate - but good enough for typings
FrozenDict = Dict[str, Any]

class PythonArtifact: ...

{functions}`;
