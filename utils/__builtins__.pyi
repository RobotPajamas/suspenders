
# This file is generated by generate-builtins.py

from __future__ import annotations

from collections.abc import Iterable
from typing import Any, Dict, Tuple, Union

# Not quite accurate - but good enough for typings
FrozenDict = Dict[str, Any]


def _generator_sources_helper(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None
) -> None:
    """
    A private helper target type used by some target generators.

    A private helper target type used by some target generators.

This tracks their `source` / `sources` field so that `--changed-since --changed-dependents` works properly for generated targets.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    """


def _lockfile(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A target for lockfiles in order to include them in the dependency graph of other targets.

    A target for lockfiles in order to include them in the dependency graph of other targets.

This tracks them so that `--changed-since --changed-dependents` works properly for targets relying on a particular lockfile.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def _lockfiles(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `_lockfile` target for each file in the `sources` field.

    Generate a `_lockfile` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.lock']`
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def archive(
    name: str,
    format: 'tar' | 'tar.bz2' | 'tar.gz' | 'tar.xz' | 'zip',
    tags: Iterable[str] | None = None,
    description: str | None = None,
    output_path: str | None = None,
    packages: Iterable[str] | None = None,
    files: Iterable[str] | None = None
) -> None:
    """
    A ZIP or TAR file containing loose files and code packages.

    A ZIP or TAR file containing loose files and code packages.

    :param name: The name of the target
    :param format: The type of archive file to be generated.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param output_path: Where the built asset should be located.

If undefined, this will use the path to the BUILD file, followed by the target name. For example, `src/python/project:app` would be `src.python.project/app.ext`.

When running `pants package`, this path will be prefixed by `--distdir` (e.g. `dist/`).

Warning: setting this value risks naming collisions with other package targets you may have.
    :param packages: Addresses to any targets that can be built with `pants package`, e.g. `["project:app"]`.

Pants will build the assets as if you had run `pants package`. It will include the results in your archive using the same name they would normally have, but without the `--distdir` prefix (e.g. `dist/`).

You can include anything that can be built by `pants package`, e.g. a `pex_binary`, `python_awslambda`, or even another `archive`.
    :param files: Addresses to any `file`, `files`, or `relocated_files` targets to include in the archive, e.g. `["resources:logo"]`.

This is useful to include any loose files, like data files, image assets, or config files.

This will ignore any targets that are not `file`, `files`, or `relocated_files` targets.

If you instead want those files included in any packages specified in the `packages` field for this target, then use a `resource` or `resources` target and have the original package depend on the resources.
    """


def cc_source(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    skip_clang_format: bool = False
) -> None:
    """
    A single C/C++ source file or header file.

    A single C/C++ source file or header file.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param skip_clang_format: If true, don't run clang-format on this target's code.
    """


def cc_sources(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*.h', '*.hh', '*.hpp', '*.c', '*.cc', '*.cpp', '*.cxx'),
    skip_clang_format: bool = False,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `cc_source` target for each file in the `sources` field.

    Generate a `cc_source` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.cpp', 'new_*.cc', '!old_ignore.cc']`
    :param skip_clang_format: If true, don't run clang-format on this target's code.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def docker_environment(
    name: str,
    image: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    platform: 'linux_arm64' | 'linux_x86_64' | 'macos_arm64' | 'macos_x86_64' | None = None,
    fallback_environment: str | None = None,
    python_bootstrap_names: Iterable[str] | None = None,
    python_native_code_ld_flags: Iterable[str] | None = None,
    python_bootstrap_search_path: Iterable[str] | None = None,
    python_native_code_cpp_flags: Iterable[str] | None = None,
    pex_executable_search_paths: Iterable[str] | None = None,
    nodejs_corepack_env_vars: Iterable[str] | None = None,
    nodejs_search_path: Iterable[str] | None = None,
    shell_setup_executable_search_paths: Iterable[str] | None = None,
    subprocess_environment_env_vars: Iterable[str] | None = None,
    test_extra_env_vars: Iterable[str] | None = None,
    nodejs_executable_search_paths: Iterable[str] | None = None,
    system_binaries_system_binary_paths: Iterable[str] | None = None
) -> None:
    """
    Configuration of a Docker environment used for building your code.

    Configuration of a Docker environment used for building your code.

Environment configuration includes both Docker-specific information (including the image and platform choice), as well as environment-aware options (such as environment variables and search paths) used by Pants to execute processes in this Docker environment.

To use this environment, map this target's address with a memorable name in `[environments-preview].names`. You can then consume this environment by specifying the name in the `environment` field defined on other targets.

Before running Pants using this environment, if you are using Docker Desktop, make sure the option **Enable default Docker socket** is enabled, you can find it in **Docker Desktop Settings > Advanced** panel. That option tells Docker to create a socket at `/var/run/docker.sock` which Pants can use to communicate with Docker.

    :param name: The name of the target
    :param image: The docker image ID to use when this environment is loaded.

This value may be any image identifier that the local Docker installation can accept. This includes image names with or without tags (e.g. `centos6` or `centos6:latest`), or image names with an immutable digest (e.g. `centos@sha256:<some_sha256_value>`).

The choice of image ID can affect the reproducibility of builds. Consider using an immutable digest if reproducibility is needed, but regularly ensure that the image is free of relevant bugs or security vulnerabilities.

Note that in order to use an image as a `docker_environment` it must have a few tools: - `/bin/sh` - `/usr/bin/env` - `bash` - `tar`

While most images will have these preinstalled, users of base images such as Distroless or scratch will need to bake these tools into the image themselves. All of these except `bash` are available via busybox.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param platform: If set, Docker will always use the specified platform when pulling and running the image.

If unset, Pants will default to the CPU architecture of your local host machine. For example, if you are running on Apple Silicon, it will use `linux_arm64`, whereas running on Intel macOS will use `linux_x86_64`. This mirrors Docker's behavior when `--platform` is left off.
    :param fallback_environment: The environment to fallback to when this Docker environment cannot be used because either the global option `--docker-execution` is false, or the field `platform` is not compatible with the local host's CPU architecture (this is only an issue when the local host is Linux; macOS is fine).

Must be an environment name from the option `[environments-preview].names`, the special string `__local__` to use the relevant local environment, or the Python value `None` to error when this specific Docker environment cannot be used.
    :param python_bootstrap_names: Overrides the default value from the option `[python-bootstrap].names` when this environment target is active.
    :param python_native_code_ld_flags: Overrides the default value from the option `[python-native-code].ld_flags` when this environment target is active.
    :param python_bootstrap_search_path: Overrides the default value from the option `[python-bootstrap].search_path` when this environment target is active.
    :param python_native_code_cpp_flags: Overrides the default value from the option `[python-native-code].cpp_flags` when this environment target is active.
    :param pex_executable_search_paths: Overrides the default value from the option `[pex].executable_search_paths` when this environment target is active.
    :param nodejs_corepack_env_vars: Overrides the default value from the option `[nodejs].corepack_env_vars` when this environment target is active.
    :param nodejs_search_path: Overrides the default value from the option `[nodejs].search_path` when this environment target is active.
    :param shell_setup_executable_search_paths: Overrides the default value from the option `[shell-setup].executable_search_paths` when this environment target is active.
    :param subprocess_environment_env_vars: Overrides the default value from the option `[subprocess-environment].env_vars` when this environment target is active.
    :param test_extra_env_vars: Overrides the default value from the option `[test].extra_env_vars` when this environment target is active.
    :param nodejs_executable_search_paths: Overrides the default value from the option `[nodejs].executable_search_paths` when this environment target is active.
    :param system_binaries_system_binary_paths: Overrides the default value from the option `[system-binaries].system_binary_paths` when this environment target is active.
    """


def experimental_test_shell_command(
    name: str,
    command: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    execution_dependencies: Iterable[str] | None = None,
    log_output: bool = False,
    timeout: int | None = 30,
    tools: Iterable[str] | None = (),
    extra_env_vars: Iterable[str] | None = None,
    environment: str | None = '__local__',
    skip_tests: bool = False,
    workdir: str | None = '.'
) -> None:
    """
    Run a script as a test via the `test` goal, with all dependencies packaged/copied available in the chroot.

    Run a script as a test via the `test` goal, with all dependencies packaged/copied available in the chroot.

Example BUILD file:

    experimental_test_shell_command(
        name="test",
        tools=["test"],
        command="test -r $CHROOT/some-data-file.txt",
        execution_dependencies=["src/project/files:data"],
    )

The `command` may use either `{chroot}` on the command line, or the `$CHROOT` environment variable to get the root directory for where any dependencies are located.

In contrast to the `run_shell_command`, this target is intended to run shell commands as tests and will only run them via the `test` goal.

    :param name: The name of the target
    :param command: Shell command to execute.

The command is executed as `'bash -c <command>'` by default. If you want to invoke a binary use `exec -a $0 <binary> <args>` as the command so that the binary gets the correct `argv[0]` set.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param execution_dependencies: The execution dependencies for this command.

Dependencies specified here are those required to make the command complete successfully (e.g. file inputs, packages compiled from other targets, etc), but NOT required to make the outputs of the command useful. Dependencies that are required to use the outputs produced by this command should be specified using the `output_dependencies` field.

If this field is specified, dependencies from `output_dependencies` will not be added to the execution sandbox.

See also `output_dependencies` and `runnable_dependencies`.
    :param log_output: Set to true if you want the output logged to the console.
    :param timeout: Command execution timeout (in seconds).
    :param tools: Specify required executable tools that might be used.

Only the tools explicitly provided will be available on the search PATH, and these tools must be found on the paths provided by `[shell-setup].executable_search_paths` (which defaults to the system PATH).
    :param extra_env_vars: Additional environment variables to provide to the process.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    :param skip_tests: If true, don't run this tests for target.
    :param workdir: Sets the working directory for the process.

Values are relative to the build root, except in the following cases:

* `.` specifies the location of the `BUILD` file.
* Values beginning with `./` are relative to the location of the `BUILD` file.
* `/` or the empty string specifies the build root.
* Values beginning with `/` are also relative to the build root.
    """


def experimental_wrap_as_python_sources(
    name: str,
    inputs: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    outputs: Iterable[str] | None = None
) -> None:
    """
    Allow files and sources produced by the targets specified by `inputs` to be consumed by rules that specifically expect a `PythonSourceField`.

    Allow files and sources produced by the targets specified by `inputs` to be consumed by rules that specifically expect a `PythonSourceField`.

Note that this target does not modify the files in any way. If `outputs` is not specified, all files with the following extensions will be matched: .py, .pyi

This target must be explicitly specified as a dependency of any target that requires it. Sources from this target will not be automatically inferred as dependencies.

This target is experimental: in future versions of Pants, this functionality may be made available with a different interface.

    :param name: The name of the target
    :param inputs: The input targets that are to be made available by this target.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param outputs: The output files that are made available in the new context by this target. If not specified, the target will capture all files with the expected extensions for this source format: see the help for the target for the specific extensions. If no extensions are specified and this value is not specified, all input files will be returned.
    """


def experimental_wrap_as_resources(
    name: str,
    inputs: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    outputs: Iterable[str] | None = None
) -> None:
    """
    Allow files and sources produced by the targets specified by `inputs` to be consumed by rules that specifically expect a `ResourceSourceField`.

    Allow files and sources produced by the targets specified by `inputs` to be consumed by rules that specifically expect a `ResourceSourceField`.

Note that this target does not modify the files in any way. If `outputs` is not specified, all files from `inputs` will be matched.

This target must be explicitly specified as a dependency of any target that requires it. Sources from this target will not be automatically inferred as dependencies.

This target is experimental: in future versions of Pants, this functionality may be made available with a different interface.

    :param name: The name of the target
    :param inputs: The input targets that are to be made available by this target.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param outputs: The output files that are made available in the new context by this target. If not specified, the target will capture all files with the expected extensions for this source format: see the help for the target for the specific extensions. If no extensions are specified and this value is not specified, all input files will be returned.
    """


def file(
    name: str,
    source: str | http_source | pants.core.target_types.per_platform[pants.core.target_types.http_source],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A single loose file that lives outside of code packages.

    A single loose file that lives outside of code packages.

Files are placed directly in archives, outside of code artifacts such as Python wheels or JVM JARs. The sources of a `file` target are accessed via filesystem APIs, such as Python's `open()`, via paths relative to the repository root.

    :param name: The name of the target
    :param source: The source of this target.

If a string is provided, represents a path that is relative to the BUILD file's directory, e.g. `source='example.ext'`.

If an `http_source` is provided, represents the network location to download the source from. The downloaded file will exist in the sandbox in the same directory as the target.

`http_source` has the following signature:

    http_source(url: str, *, len: int, sha256: str, filename: str = "")

The filename defaults to the last part of the URL path (e.g. `example.ext`), but can also be specified if you wish to have control over the file name. You cannot, however, specify a path separator to download the file into a subdirectory (you must declare a target in desired subdirectory).

You can easily get the len and checksum with the following command:

    curl -L $URL | tee >(wc -c) >(shasum -a 256) >/dev/null

If a `per_platform` is provided, represents a mapping from platform to `http_source`, where the platform is one of (`linux_arm64`, `linux_x86_64`, `macos_arm64`, `macos_x86_64`) and is resolved in the execution target. Each `http_source` value MUST have the same filename provided.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def files(
    name: str,
    sources: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `file` target for each file in the `sources` field.

    Generate a `file` target for each file in the `sources` field.

    :param name: The name of the target
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.txt', 'new_*.md', '!old_ignore.csv']`
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param overrides: Override the field values for generated `file` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.json": {"description": "our customer model"]},
        "bar.json": {"description": "our product model"]},
        ("foo.json", "bar.json"): {"tags": ["overridden"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `file` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def javascript_source(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    skip_prettier: bool = False
) -> None:
    """
    A single Javascript source file.

    A single Javascript source file.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param skip_prettier: If true, don't run Prettier on this target's code.
    """


def javascript_sources(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*.js', '*.cjs', '*.mjs', '!*.test.js', '!*.test.cjs', '!*.test.mjs'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_prettier: bool = False,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `javascript_source` target for each file in the `sources` field.

    Generate a `javascript_source` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['utils.js', 'subdir/*.js', '!ignore_me.js']`
    :param overrides: Override the field values for generated `javascript_source` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.js": {"skip_prettier": True},
        "bar.js": {"skip_prettier": True},
        ("foo.js", "bar.js"): {"tags": ["no_lint"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `javascript_source` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_prettier: If true, don't run Prettier on this target's code.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def javascript_test(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    timeout: int | None = None,
    extra_env_vars: Iterable[str] | None = None,
    batch_compatibility_tag: str | None = None
) -> None:
    """
    A single Javascript test file.

    A single Javascript test file.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param extra_env_vars: Additional environment variables to include in test processes.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.

This will be merged with and override values from `[test].extra_env_vars`.
    :param batch_compatibility_tag: An arbitrary value used to mark the test files belonging to this target as valid for batched execution.

It's _sometimes_ safe to run multiple `javascript_test`s within a single test runner process, and doing so can give significant wins by allowing reuse of expensive test setup / teardown logic. To opt into this behavior, set this field to an arbitrary non-empty string on all the `javascript_test` targets that are safe/compatible to run in the same process.

If this field is left unset on a target, the target is assumed to be incompatible with all others and will run in a dedicated `nodejs test runner` process.

If this field is set on a target, and its value is different from the value on some other test `javascript_test`, then the two targets are explicitly incompatible and are guaranteed to not run in the same `nodejs test runner` process.

If this field is set on a target, and its value is the same as the value on some other `javascript_test`, then the two targets are explicitly compatible and _may_ run in the same test runner process. Compatible tests may not end up in the same test runner batch if:

  * There are "too many" compatible tests in a partition, as determined by the `[test].batch_size` config parameter, or
  * Compatible tests have some incompatibility in Pants metadata (i.e. different `resolve`s or `extra_env_vars`).

When tests with the same `batch_compatibility_tag` have incompatibilities in some other Pants metadata, they will be automatically split into separate batches. This way you can set a high-level `batch_compatibility_tag` using `__defaults__` and then have tests continue to work as you tweak BUILD metadata on specific targets.
    """


def javascript_tests(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*.test.js', '*.test.cjs', '*.test.mjs'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    dependencies: Iterable[str] | None = None,
    timeout: int | None = None,
    extra_env_vars: Iterable[str] | None = None,
    batch_compatibility_tag: str | None = None
) -> None:
    """
    Generate a `javascript_test` target for each file in the `sources` field.

    Generate a `javascript_test` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['utils.test.js', 'subdir/*.test.mjs', '!ignore_me.test.js']`
    :param overrides: Override the field values for generated `javascript_test` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.test.js": {"timeout": 120},
        "bar.test.js": {"timeout": 200},
        ("foo.test.js", "bar.test.js"): {"tags": ["slow_tests"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `javascript_test` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param extra_env_vars: Additional environment variables to include in test processes.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.

This will be merged with and override values from `[test].extra_env_vars`.
    :param batch_compatibility_tag: An arbitrary value used to mark the test files belonging to this target as valid for batched execution.

It's _sometimes_ safe to run multiple `javascript_test`s within a single test runner process, and doing so can give significant wins by allowing reuse of expensive test setup / teardown logic. To opt into this behavior, set this field to an arbitrary non-empty string on all the `javascript_test` targets that are safe/compatible to run in the same process.

If this field is left unset on a target, the target is assumed to be incompatible with all others and will run in a dedicated `nodejs test runner` process.

If this field is set on a target, and its value is different from the value on some other test `javascript_test`, then the two targets are explicitly incompatible and are guaranteed to not run in the same `nodejs test runner` process.

If this field is set on a target, and its value is the same as the value on some other `javascript_test`, then the two targets are explicitly compatible and _may_ run in the same test runner process. Compatible tests may not end up in the same test runner batch if:

  * There are "too many" compatible tests in a partition, as determined by the `[test].batch_size` config parameter, or
  * Compatible tests have some incompatibility in Pants metadata (i.e. different `resolve`s or `extra_env_vars`).

When tests with the same `batch_compatibility_tag` have incompatibilities in some other Pants metadata, they will be automatically split into separate batches. This way you can set a high-level `batch_compatibility_tag` using `__defaults__` and then have tests continue to work as you tweak BUILD metadata on specific targets.
    """


def local_environment(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    compatible_platforms: Iterable[str] | None = ('linux_arm64', 'linux_x86_64', 'macos_arm64', 'macos_x86_64'),
    fallback_environment: str | None = None,
    python_bootstrap_names: Iterable[str] | None = None,
    python_native_code_ld_flags: Iterable[str] | None = None,
    python_bootstrap_search_path: Iterable[str] | None = None,
    python_native_code_cpp_flags: Iterable[str] | None = None,
    pex_executable_search_paths: Iterable[str] | None = None,
    nodejs_corepack_env_vars: Iterable[str] | None = None,
    nodejs_search_path: Iterable[str] | None = None,
    shell_setup_executable_search_paths: Iterable[str] | None = None,
    subprocess_environment_env_vars: Iterable[str] | None = None,
    test_extra_env_vars: Iterable[str] | None = None,
    nodejs_executable_search_paths: Iterable[str] | None = None,
    system_binaries_system_binary_paths: Iterable[str] | None = None
) -> None:
    """
    Configuration of a local execution environment for specific platforms.

    Configuration of a local execution environment for specific platforms.

Environment configuration includes the platforms the environment is compatible with, and optionally a fallback environment, along with environment-aware options (such as environment variables and search paths) used by Pants to execute processes in this environment.

To use this environment, map this target's address with a memorable name in `[environments-preview].names`. You can then consume this environment by specifying the name in the `environment` field defined on other targets.

Only one `local_environment` may be defined in `[environments-preview].names` per platform, and when `__local__` is specified as the environment, the `local_environment` that matches the current platform (if defined) will be selected.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param compatible_platforms: Which platforms this environment can be used with.

This is used for Pants to automatically determine which environment target to use for the user's machine when the environment is set to the special value `__local__`. Currently, there cannot be more than one environment target registered in `[environments-preview].names` for a particular platform. If there is no environment target for a certain platform, Pants will use the options system instead to determine environment variables and executable search paths.
    :param fallback_environment: The environment to fallback to when this local environment cannot be used because the field `compatible_platforms` is not compatible with the local host.

Must be an environment name from the option `[environments-preview].names`, the special string `__local__` to use the relevant local environment, or the Python value `None` to error when this specific local environment cannot be used.

Tip: when targeting Linux, it can be particularly helpful to fallback to a `docker_environment` or `remote_environment` target. That allows you to prefer using the local host when possible, which often has less overhead (particularly compared to Docker). If the local host is not compatible, then Pants will use Docker or remote execution to still run in a similar environment.
    :param python_bootstrap_names: Overrides the default value from the option `[python-bootstrap].names` when this environment target is active.
    :param python_native_code_ld_flags: Overrides the default value from the option `[python-native-code].ld_flags` when this environment target is active.
    :param python_bootstrap_search_path: Overrides the default value from the option `[python-bootstrap].search_path` when this environment target is active.
    :param python_native_code_cpp_flags: Overrides the default value from the option `[python-native-code].cpp_flags` when this environment target is active.
    :param pex_executable_search_paths: Overrides the default value from the option `[pex].executable_search_paths` when this environment target is active.
    :param nodejs_corepack_env_vars: Overrides the default value from the option `[nodejs].corepack_env_vars` when this environment target is active.
    :param nodejs_search_path: Overrides the default value from the option `[nodejs].search_path` when this environment target is active.
    :param shell_setup_executable_search_paths: Overrides the default value from the option `[shell-setup].executable_search_paths` when this environment target is active.
    :param subprocess_environment_env_vars: Overrides the default value from the option `[subprocess-environment].env_vars` when this environment target is active.
    :param test_extra_env_vars: Overrides the default value from the option `[test].extra_env_vars` when this environment target is active.
    :param nodejs_executable_search_paths: Overrides the default value from the option `[nodejs].executable_search_paths` when this environment target is active.
    :param system_binaries_system_binary_paths: Overrides the default value from the option `[system-binaries].system_binary_paths` when this environment target is active.
    """


def node_package(
    name: str,
    package: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    source: str | None = 'package.json',
    version: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A first party node package.

    A first party node package.

    :param name: The name of the target
    :param package: Name of the Node package, as specified in the package.json.

This field should not be overridden; use the value from target generation.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param version: Version of the Node package, as specified in the package.json.

This field should not be overridden; use the value from target generation.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def node_third_party_package(
    name: str,
    package: str,
    version: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A third party node package.

    A third party node package.

    :param name: The name of the target
    :param package: Name of the Node package, as specified in the package.json.

This field should not be overridden; use the value from target generation.
    :param version: Version of the Node package, as specified in the package.json.

This field should not be overridden; use the value from target generation.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def package_json(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    source: str | None = 'package.json',
    scripts: Iterable[Any] | None = (),
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A package.json file describing a nodejs package. (https://nodejs.org/api/packages.html#introduction)

    A package.json file describing a nodejs package. (https://nodejs.org/api/packages.html#introduction)

Generates a `node_package` target for the package.

Generates `node_third_party_package` targets for each specified 3rd party dependency (e.g. in the package.json#devDependencies field).

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param scripts: Custom node package manager scripts that should be known and ran as part of relevant goals.

Maps the package.json#scripts section to a cacheable pants invocation.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def pants_requirements(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    version_spec: str | None = '== 2.20.1',
    testutil: bool = True,
    resolve: str | None = None
) -> None:
    """
    Generate `python_requirement` targets for Pants itself to use with Pants plugins.

    Generate `python_requirement` targets for Pants itself to use with Pants plugins.

This is useful when writing plugins so that you can build and test your plugin using Pants.

The generated targets will have the correct version based on the exact `version` in your `pants.toml`, and they will work with dependency inference. They're pulled directly from our GitHub releases, using the relevant platform markers.

(If this versioning scheme does not work for you, you can directly create `python_requirement` targets for `pantsbuild.pants` and `pantsbuild.pants.testutil`. We also invite you to share your ideas at https://github.com/pantsbuild/pants/issues/new/choose)

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param version_spec: The PEP 440 version specifier version of Pants to target. E.g. `== 2.15.*`, or `>= 2.16.0, < 2.17.0`
    :param testutil: If true, include `pantsbuild.pants.testutil` to write tests for your plugin.
    :param resolve: The resolve from `[python].resolves` that this requirement is included in.

If not defined, will default to `[python].default_resolve`.

When generating a lockfile for a particular resolve via the `generate-lockfiles` goal, it will include all requirements that are declared with that resolve. First-party targets like `python_source` and `pex_binary` then declare which resolve they use via their `resolve` field; so, for your first-party code to use a particular `python_requirement` target, that requirement must be included in the resolve used by that code.
    """


def pex_binaries(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    entry_points: Iterable[str] | None = None,
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    environment: str | None = '__local__',
    interpreter_constraints: Iterable[str] | None = None,
    resolve: str | None = None,
    dependencies: Iterable[str] | None = None,
    check: 'error' | 'none' | 'warn' | None = 'warn',
    complete_platforms: Iterable[str] | None = None,
    resolve_local_platforms: bool | None = None,
    inherit_path: 'fallback' | 'false' | 'prefer' | None = None,
    strip_pex_env: bool = True,
    ignore_errors: bool = False,
    sh_boot: bool = False,
    shebang: str | None = None,
    emit_warnings: bool | None = None,
    layout: 'loose' | 'packed' | 'zipapp' | None = 'zipapp',
    execution_mode: 'venv' | 'zipapp' | None = 'zipapp',
    include_requirements: bool = True,
    include_sources: bool = True,
    include_tools: bool = False,
    venv_site_packages_copies: bool = False,
    venv_hermetic_scripts: bool = True,
    restartable: bool = False
) -> None:
    """
    Generate a `pex_binary` target for each entry_point in the `entry_points` field.

    Generate a `pex_binary` target for each entry_point in the `entry_points` field.

This is solely meant to reduce duplication when you have multiple scripts in the same directory; it's valid to use a distinct `pex_binary` target for each script/binary instead.

This target generator does not work well to generate `pex_binary` targets where the entry point is for a third-party dependency. Dependency inference will not work for those, so you will have to set lots of custom metadata for each binary; prefer an explicit `pex_binary` target in that case. This target generator works best when the entry point is a first-party file, like `app.py` or `app.py:main`.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param entry_points: The entry points for each binary, i.e. what gets run when when executing `./my_app.pex.`

Use a file name, relative to the BUILD file, like `app.py`. You can also set the function to run, like `app.py:func`. Pants will convert these file names into well-formed entry points, like `app.py:func` into `path.to.app:func.`

If you want the entry point to be for a third-party dependency or to use a console script, use the `pex_binary` target directly.
    :param overrides: Override the field values for generated `pex_binary` targets.

Expects a dictionary mapping values from the `entry_points` field to a dictionary for their overrides. You may either use a single string or a tuple of strings to override multiple targets.

For example:

    overrides={
      "foo.py": {"execution_mode": "venv"]},
      "bar.py:main": {"restartable": True]},
      ("foo.py", "bar.py:main"): {"tags": ["legacy"]},
    }

Every key is validated to belong to this target's `entry_points` field.

If you'd like to override a field's value for every `pex_binary` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same `entry_point` in multiple keys, so long as you don't override the same field more than one time for the `entry_point`.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param check: Check that the built PEX is valid. Currently this only applies to `--layout zipapp` where the PEX zip is tested for importability of its `__main__` module by the Python zipimport module. This check will fail for PEX zips that use ZIP64 extensions since the Python zipimport zipimporter only works with 32 bit zips. The check no-ops for all other layouts.
    :param complete_platforms: The platforms the built PEX should be compatible with.

There must be built wheels available for all of the foreign platforms, rather than sdists.

You can give a list of multiple complete platforms to create a multiplatform PEX, meaning that the PEX will be executable in all of the supported environments.

Complete platforms should be addresses of `file` targets that point to files that contain complete platform JSON as described by Pex (https://pex.readthedocs.io/en/latest/buildingpex.html#complete-platform).

See https://www.pantsbuild.org/2.20/docs/python/overview/pex for details.
    :param resolve_local_platforms: For each of the `platforms` specified, attempt to find a local interpreter that matches.

If a matching interpreter is found, use the interpreter to resolve distributions and build any that are only available in source distribution form. If no matching interpreter is found (or if this option is `False`), resolve for the platform by accepting only pre-built binary distributions (wheels).
    :param inherit_path: Whether to inherit the `sys.path` (aka PYTHONPATH) of the environment that the binary runs in.

Use `false` to not inherit `sys.path`; use `fallback` to inherit `sys.path` after packaged dependencies; and use `prefer` to inherit `sys.path` before packaged dependencies.
    :param strip_pex_env: Whether or not to strip the PEX runtime environment of `PEX*` environment variables.

Most applications have no need for the `PEX*` environment variables that are used to control PEX startup; so these variables are scrubbed from the environment by Pex before transferring control to the application by default. This prevents any subprocesses that happen to execute other PEX files from inheriting these control knob values since most would be undesired; e.g.: PEX_MODULE or PEX_PATH.
    :param ignore_errors: Should PEX ignore errors when it cannot resolve dependencies?
    :param sh_boot: Should PEX create a modified ZIPAPP that uses `/bin/sh` to boot?

If you know the machines that the PEX will be distributed to have POSIX compliant `/bin/sh` (almost all do, see: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html); then this is probably the way you want your PEX to boot. Instead of launching via a Python shebang, the PEX will launch via a `#!/bin/sh` shebang that executes a small script embedded in the head of the PEX ZIPAPP that performs initial interpreter selection and re-execution of the underlying PEX in a way that is often more robust than a Python shebang and always faster on 2nd and subsequent runs since the sh script has a constant overhead of O(1ms) whereas the Python overhead to perform the same interpreter selection and re-execution is O(100ms).
    :param shebang: Set the generated PEX to use this shebang, rather than the default of PEX choosing a shebang based on the interpreter constraints.

This influences the behavior of running `./result.pex`. You can ignore the shebang by instead running `/path/to/python_interpreter ./result.pex`.
    :param emit_warnings: Whether or not to emit PEX warnings at runtime.

The default is determined by the option `emit_warnings` in the `[pex-binary-defaults]` scope.
    :param layout: The layout used for the PEX binary.

By default, a PEX is created as a single file zipapp, but either a packed or loose directory tree based layout can be chosen instead.

A packed layout PEX is an executable directory structure designed to have cache-friendly characteristics for syncing incremental updates to PEXed applications over a network. At the top level of the packed directory tree there is an executable `__main__.py` script. The directory can also be executed by passing its path to a Python executable; e.g: `python packed-pex-dir/`. The Pex bootstrap code and all dependency code are packed into individual zip files for efficient caching and syncing.

A loose layout PEX is similar to a packed PEX, except that neither the Pex bootstrap code nor the dependency code are packed into zip files, but are instead present as collections of loose files in the directory tree providing different caching and syncing tradeoffs.

Both zipapp and packed layouts install themselves in the `$PEX_ROOT` as loose apps by default before executing, but these layouts compose with `execution_mode='zipapp'` as well.
    :param execution_mode: The mode the generated PEX file will run in.

The traditional PEX file runs in a modified 'zipapp' mode (See: https://www.python.org/dev/peps/pep-0441/) where zipped internal code and dependencies are first unpacked to disk. This mode achieves the fastest cold start times and may, for example be the best choice for cloud lambda functions.

The fastest execution mode in the steady state is 'venv', which generates a virtual environment from the PEX file on first run, but then achieves near native virtual environment start times. This mode also benefits from a traditional virtual environment `sys.path`, giving maximum compatibility with stdlib and third party APIs.
    :param include_requirements: Whether to include the third party requirements the binary depends on in the packaged PEX file.
    :param include_sources: Whether to include your first party sources the binary uses in the packaged PEX file.
    :param include_tools: Whether to include Pex tools in the PEX bootstrap code.

With tools included, the generated PEX file can be executed with `PEX_TOOLS=1 <pex file> --help` to gain access to all the available tools.
    :param venv_site_packages_copies: If execution_mode is venv, populate the venv site packages using hard links or copies of resolved PEX dependencies instead of symlinks.

This can be used to work around problems with tools or libraries that are confused by symlinked source files.
    :param venv_hermetic_scripts: If execution_mode is "venv", emit a hermetic venv `pex` script and hermetic console scripts.

The venv `pex` script and the venv console scripts are constructed to be hermetic by default; Python is executed with `-sE` to restrict the `sys.path` to the PEX venv contents only. Setting this field to `False` elides the Python `-sE` restrictions and can be used to interoperate with frameworks that use `PYTHONPATH` manipulation to run code.
    :param restartable: If true, runs of this target with the `run` goal may be interrupted and restarted when its input files change.
    """


def pex_binary(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    environment: str | None = '__local__',
    interpreter_constraints: Iterable[str] | None = None,
    resolve: str | None = None,
    dependencies: Iterable[str] | None = None,
    check: 'error' | 'none' | 'warn' | None = 'warn',
    complete_platforms: Iterable[str] | None = None,
    resolve_local_platforms: bool | None = None,
    inherit_path: 'fallback' | 'false' | 'prefer' | None = None,
    strip_pex_env: bool = True,
    ignore_errors: bool = False,
    sh_boot: bool = False,
    shebang: str | None = None,
    emit_warnings: bool | None = None,
    layout: 'loose' | 'packed' | 'zipapp' | None = 'zipapp',
    execution_mode: 'venv' | 'zipapp' | None = 'zipapp',
    include_requirements: bool = True,
    include_sources: bool = True,
    include_tools: bool = False,
    venv_site_packages_copies: bool = False,
    venv_hermetic_scripts: bool = True,
    restartable: bool = False,
    entry_point: str | None = None,
    script: str | None = None,
    executable: str | None = None,
    args: Iterable[str] | None = None,
    env: Dict[str, str] | None = None,
    output_path: str | None = None
) -> None:
    """
    A Python target that can be converted into an executable PEX file.

    A Python target that can be converted into an executable PEX file.

PEX files are self-contained executable files that contain a complete Python environment capable of running the target. For more information, see https://www.pantsbuild.org/2.20/docs/python/overview/pex.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param check: Check that the built PEX is valid. Currently this only applies to `--layout zipapp` where the PEX zip is tested for importability of its `__main__` module by the Python zipimport module. This check will fail for PEX zips that use ZIP64 extensions since the Python zipimport zipimporter only works with 32 bit zips. The check no-ops for all other layouts.
    :param complete_platforms: The platforms the built PEX should be compatible with.

There must be built wheels available for all of the foreign platforms, rather than sdists.

You can give a list of multiple complete platforms to create a multiplatform PEX, meaning that the PEX will be executable in all of the supported environments.

Complete platforms should be addresses of `file` targets that point to files that contain complete platform JSON as described by Pex (https://pex.readthedocs.io/en/latest/buildingpex.html#complete-platform).

See https://www.pantsbuild.org/2.20/docs/python/overview/pex for details.
    :param resolve_local_platforms: For each of the `platforms` specified, attempt to find a local interpreter that matches.

If a matching interpreter is found, use the interpreter to resolve distributions and build any that are only available in source distribution form. If no matching interpreter is found (or if this option is `False`), resolve for the platform by accepting only pre-built binary distributions (wheels).
    :param inherit_path: Whether to inherit the `sys.path` (aka PYTHONPATH) of the environment that the binary runs in.

Use `false` to not inherit `sys.path`; use `fallback` to inherit `sys.path` after packaged dependencies; and use `prefer` to inherit `sys.path` before packaged dependencies.
    :param strip_pex_env: Whether or not to strip the PEX runtime environment of `PEX*` environment variables.

Most applications have no need for the `PEX*` environment variables that are used to control PEX startup; so these variables are scrubbed from the environment by Pex before transferring control to the application by default. This prevents any subprocesses that happen to execute other PEX files from inheriting these control knob values since most would be undesired; e.g.: PEX_MODULE or PEX_PATH.
    :param ignore_errors: Should PEX ignore errors when it cannot resolve dependencies?
    :param sh_boot: Should PEX create a modified ZIPAPP that uses `/bin/sh` to boot?

If you know the machines that the PEX will be distributed to have POSIX compliant `/bin/sh` (almost all do, see: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html); then this is probably the way you want your PEX to boot. Instead of launching via a Python shebang, the PEX will launch via a `#!/bin/sh` shebang that executes a small script embedded in the head of the PEX ZIPAPP that performs initial interpreter selection and re-execution of the underlying PEX in a way that is often more robust than a Python shebang and always faster on 2nd and subsequent runs since the sh script has a constant overhead of O(1ms) whereas the Python overhead to perform the same interpreter selection and re-execution is O(100ms).
    :param shebang: Set the generated PEX to use this shebang, rather than the default of PEX choosing a shebang based on the interpreter constraints.

This influences the behavior of running `./result.pex`. You can ignore the shebang by instead running `/path/to/python_interpreter ./result.pex`.
    :param emit_warnings: Whether or not to emit PEX warnings at runtime.

The default is determined by the option `emit_warnings` in the `[pex-binary-defaults]` scope.
    :param layout: The layout used for the PEX binary.

By default, a PEX is created as a single file zipapp, but either a packed or loose directory tree based layout can be chosen instead.

A packed layout PEX is an executable directory structure designed to have cache-friendly characteristics for syncing incremental updates to PEXed applications over a network. At the top level of the packed directory tree there is an executable `__main__.py` script. The directory can also be executed by passing its path to a Python executable; e.g: `python packed-pex-dir/`. The Pex bootstrap code and all dependency code are packed into individual zip files for efficient caching and syncing.

A loose layout PEX is similar to a packed PEX, except that neither the Pex bootstrap code nor the dependency code are packed into zip files, but are instead present as collections of loose files in the directory tree providing different caching and syncing tradeoffs.

Both zipapp and packed layouts install themselves in the `$PEX_ROOT` as loose apps by default before executing, but these layouts compose with `execution_mode='zipapp'` as well.
    :param execution_mode: The mode the generated PEX file will run in.

The traditional PEX file runs in a modified 'zipapp' mode (See: https://www.python.org/dev/peps/pep-0441/) where zipped internal code and dependencies are first unpacked to disk. This mode achieves the fastest cold start times and may, for example be the best choice for cloud lambda functions.

The fastest execution mode in the steady state is 'venv', which generates a virtual environment from the PEX file on first run, but then achieves near native virtual environment start times. This mode also benefits from a traditional virtual environment `sys.path`, giving maximum compatibility with stdlib and third party APIs.
    :param include_requirements: Whether to include the third party requirements the binary depends on in the packaged PEX file.
    :param include_sources: Whether to include your first party sources the binary uses in the packaged PEX file.
    :param include_tools: Whether to include Pex tools in the PEX bootstrap code.

With tools included, the generated PEX file can be executed with `PEX_TOOLS=1 <pex file> --help` to gain access to all the available tools.
    :param venv_site_packages_copies: If execution_mode is venv, populate the venv site packages using hard links or copies of resolved PEX dependencies instead of symlinks.

This can be used to work around problems with tools or libraries that are confused by symlinked source files.
    :param venv_hermetic_scripts: If execution_mode is "venv", emit a hermetic venv `pex` script and hermetic console scripts.

The venv `pex` script and the venv console scripts are constructed to be hermetic by default; Python is executed with `-sE` to restrict the `sys.path` to the PEX venv contents only. Setting this field to `False` elides the Python `-sE` restrictions and can be used to interoperate with frameworks that use `PYTHONPATH` manipulation to run code.
    :param restartable: If true, runs of this target with the `run` goal may be interrupted and restarted when its input files change.
    :param entry_point: Set the entry point, i.e. what gets run when executing `./my_app.pex`, to a module.

You can specify a full module like `'path.to.module'` and `'path.to.module:func'`, or use a shorthand to specify a file name, using the same syntax as the `sources` field:

  1) `'app.py'`, Pants will convert into the module `path.to.app`;
  2) `'app.py:func'`, Pants will convert into `path.to.app:func`.

You may only set one of: this field, or the `script` field, or the `executable` field. Leave off all three fields to have no entry point.
    :param script: Set the entry point, i.e. what gets run when executing `./my_app.pex`, to a script or console_script as defined by any of the distributions in the PEX.

You may only set one of: this field, or the `entry_point` field, or the `executable` field. Leave off all three fields to have no entry point.
    :param executable: Set the entry point, i.e. what gets run when executing `./my_app.pex`, to an execuatble local python script. This executable python script is typically something that cannot be imported so it cannot be used via `script` or `entry_point`.

You may only set one of: this field, or the `entry_point` field, or the `script` field. Leave off all three fields to have no entry point.
    :param args: Freeze these command-line args into the PEX. Allows you to run generic entry points on specific arguments without creating a shim file.
    :param env: Freeze these environment variables into the PEX. Allows you to run generic entry points on a specific environment without creating a shim file.
    :param output_path: Where the built asset should be located.

If undefined, this will use the path to the BUILD file, followed by the target name. For example, `src/python/project:app` would be `src.python.project/app.ext`.

When running `pants package`, this path will be prefixed by `--distdir` (e.g. `dist/`).

Warning: setting this value risks naming collisions with other package targets you may have.
    """


def pipenv_requirements(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    type_stubs_module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    source: str | None = 'Pipfile.lock',
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    resolve: str | None = None
) -> None:
    """
    Generate a `python_requirement` for each entry in `Pipenv.lock`.

    Generate a `python_requirement` for each entry in `Pipenv.lock`.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param module_mapping: A mapping of requirement names to a list of the modules they provide.

For example, `{"ansicolors": ["colors"]}`.

Any unspecified requirements will use a default. See the `modules` field from the `python_requirement` target for more information.
    :param type_stubs_module_mapping: A mapping of type-stub requirement names to a list of the modules they provide.

For example, `{"types-requests": ["requests"]}`.

If the requirement is not specified _and_ its name looks like a type stub, Pants will use a default. See the `type_stub_modules` field from the `python_requirement` target for more information.
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param overrides: Override the field values for generated `python_requirement` targets.

Expects a dictionary of requirements to a dictionary for the overrides. You may either use a string for a single requirement, or a string tuple for multiple requirements. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "django": {"dependencies": ["#setuptools"]},
        "ansicolors": {"description": "pretty colors"]},
        ("ansicolors, "django"): {"tags": ["overridden"]},
    }

Every overridden requirement is validated to be generated by this target.

You can specify the same requirement in multiple keys, so long as you don't override the same field more than one time for the requirement.
    :param resolve: The resolve from `[python].resolves` that this requirement is included in.

If not defined, will default to `[python].default_resolve`.

When generating a lockfile for a particular resolve via the `generate-lockfiles` goal, it will include all requirements that are declared with that resolve. First-party targets like `python_source` and `pex_binary` then declare which resolve they use via their `resolve` field; so, for your first-party code to use a particular `python_requirement` target, that requirement must be included in the resolve used by that code.
    """


def poetry_requirements(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    type_stubs_module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    source: str | None = 'pyproject.toml',
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    resolve: str | None = None
) -> None:
    """
    Generate a `python_requirement` for each entry in a Poetry `pyproject.toml`.

    Generate a `python_requirement` for each entry in a Poetry `pyproject.toml`.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param module_mapping: A mapping of requirement names to a list of the modules they provide.

For example, `{"ansicolors": ["colors"]}`.

Any unspecified requirements will use a default. See the `modules` field from the `python_requirement` target for more information.
    :param type_stubs_module_mapping: A mapping of type-stub requirement names to a list of the modules they provide.

For example, `{"types-requests": ["requests"]}`.

If the requirement is not specified _and_ its name looks like a type stub, Pants will use a default. See the `type_stub_modules` field from the `python_requirement` target for more information.
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param overrides: Override the field values for generated `python_requirement` targets.

Expects a dictionary of requirements to a dictionary for the overrides. You may either use a string for a single requirement, or a string tuple for multiple requirements. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "django": {"dependencies": ["#setuptools"]},
        "ansicolors": {"description": "pretty colors"]},
        ("ansicolors, "django"): {"tags": ["overridden"]},
    }

Every overridden requirement is validated to be generated by this target.

You can specify the same requirement in multiple keys, so long as you don't override the same field more than one time for the requirement.
    :param resolve: The resolve from `[python].resolves` that this requirement is included in.

If not defined, will default to `[python].default_resolve`.

When generating a lockfile for a particular resolve via the `generate-lockfiles` goal, it will include all requirements that are declared with that resolve. First-party targets like `python_source` and `pex_binary` then declare which resolve they use via their `resolve` field; so, for your first-party code to use a particular `python_requirement` target, that requirement must be included in the resolve used by that code.
    """


def python_distribution(
    name: str,
    provides: PythonArtifact,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    interpreter_constraints: Iterable[str] | None = None,
    dependencies: Iterable[str] | None = None,
    entry_points: Dict[str, Dict[str, str]] | None = None,
    generate_setup: bool | None = None,
    wheel: bool = True,
    sdist: bool = True,
    wheel_config_settings: Dict[str, Iterable[str]] | None = None,
    sdist_config_settings: Dict[str, Iterable[str]] | None = None,
    env_vars: Iterable[str] | None = None,
    long_description_path: str | None = None,
    output_path: str | None = '',
    skip_twine: bool = False,
    uses_mypyc: bool = False,
    repositories: Iterable[str] | None = None
) -> None:
    """
    A publishable Python setuptools distribution (e.g. an sdist or wheel).

    A publishable Python setuptools distribution (e.g. an sdist or wheel).

See https://www.pantsbuild.org/2.20/docs/python/overview/building-distributions.

    :param name: The name of the target
    :param provides: The setup.py kwargs for the external artifact built from this target.

You must define `name`. You can also set almost any keyword argument accepted by setup.py in the `setup()` function: (https://packaging.python.org/guides/distributing-packages-using-setuptools/#setup-args).

See https://www.pantsbuild.org/2.20/docs/writing-plugins/common-plugin-tasks/custom-python-artifact-kwargs for how to write a plugin to dynamically generate kwargs.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param entry_points: Any entry points, such as `console_scripts` and `gui_scripts`.

Specify as a nested dictionary, with a dictionary for each type of entry point, e.g. `console_scripts` vs. `gui_scripts`. Each dictionary maps the entry point name to either a setuptools entry point (`"path.to.module:func"`) or a Pants target address to a `pex_binary` target.

Example:

    entry_points={
      "console_scripts": {
        "my-script": "project.app:main",
        "another-script": "project/subdir:pex_binary_tgt"
      }
    }

Note that Pants will assume that any value that either starts with `:` or has `/` in it, is a target address to a `pex_binary` target. Otherwise, it will assume it's a setuptools entry point as defined by https://packaging.python.org/specifications/entry-points/#entry-points-specification. Use `//` as a prefix for target addresses if you need to disambiguate.

Pants will attempt to infer dependencies, which you can confirm by running:

    pants dependencies <python_distribution target address>
    :param generate_setup: Whether to generate setup information for this distribution, based on analyzing sources and dependencies. Set to False to use existing setup information, such as existing `setup.py`, `setup.cfg`, `pyproject.toml` files or similar.
    :param wheel: Whether to build a wheel for the distribution.
    :param sdist: Whether to build an sdist for the distribution.
    :param wheel_config_settings: PEP-517 config settings to pass to the build backend when building a wheel.
    :param sdist_config_settings: PEP-517 config settings to pass to the build backend when building an sdist.
    :param env_vars: Environment variables to set when running the PEP-517 build backend.

Entries are either strings in the form `ENV_VAR=value` to set an explicit value; or just `ENV_VAR` to copy the value from Pants's own environment.
    :param long_description_path: Path to a file that will be used to fill the `long_description` field in `setup.py`.

Path is relative to the build root.

Alternatively, you can set the `long_description` in the `provides` field, but not both.

This field won't automatically set `long_description_content_type` field for you. You have to specify this field yourself in the `provides` field.
    :param output_path: The path to the directory to write the distribution file to, relative the dist directory.

If undefined, this defaults to the empty path, i.e. the output goes at the top level of the dist dir.
    :param skip_twine: If true, don't publish this target's packages using Twine.
    :param uses_mypyc: If true, this distribution is built using mypyc.

In this case, Pants will build the distribution in an environment that includes mypy, as configured in the `[mypy]` subsystem, including plugins, config files, extra type stubs, and the distribution's own requirements (which normally would not be needed at build time, but in this case may provide necessary type annotations).

You will typically set this field on distributions whose `setup.py` uses `mypyc.build.mypycify()`. See https://mypyc.readthedocs.io/en/latest/index.html .
    :param repositories: List of URL addresses or Twine repository aliases where to publish the Python package.

Twine is used for publishing Python packages, so the address to any kind of repository that Twine supports may be used here.

Aliases are prefixed with `@` to refer to a config section in your Twine configuration, such as a `.pypirc` file. Use `@pypi` to upload to the public PyPi repository, which is the default when using Twine directly.
    """


def python_requirement(
    name: str,
    requirements: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    modules: Iterable[str] | None = None,
    type_stub_modules: Iterable[str] | None = None,
    resolve: str | None = None,
    entry_point: str | None = None
) -> None:
    """
    A Python requirement installable by pip.

    A Python requirement installable by pip.

This target is useful when you want to declare Python requirements inline in a BUILD file. If you have a `requirements.txt` file already, you can instead use the target generator `python_requirements` to convert each requirement into a `python_requirement` target automatically. For Poetry, use `poetry_requirements`.

See https://www.pantsbuild.org/2.20/docs/python/overview/third-party-dependencies.

    :param name: The name of the target
    :param requirements: A pip-style requirement string, e.g. `["Django==3.2.8"]`.

You can specify multiple requirements for the same project in order to use environment markers, such as `["foo>=1.2,<1.3 ; python_version>'3.6'", "foo==0.9 ; python_version<'3'"]`.

If the requirement depends on some other requirement to work, such as needing `setuptools` to be built, use the `dependencies` field instead.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param modules: The modules this requirement provides (used for dependency inference).

For example, the requirement `setuptools` provides `["setuptools", "pkg_resources", "easy_install"]`.

Usually you can leave this field off. If unspecified, Pants will first look at the default module mapping (https://github.com/pantsbuild/pants/blob/release_2.20.1/src/python/pants/backend/python/dependency_inference/default_module_mapping.py), and then will default to the normalized project name. For example, the requirement `Django` would default to the module `django`.

Mutually exclusive with the `type_stub_modules` field.
    :param type_stub_modules: The modules this requirement provides if the requirement is a type stub (used for dependency inference).

For example, the requirement `types-requests` provides `["requests"]`.

Usually you can leave this field off. If unspecified, Pants will first look at the default module mapping (https://github.com/pantsbuild/pants/blob/release_2.20.1/src/python/pants/backend/python/dependency_inference/default_module_mapping.py). If not found _and_ the requirement name starts with `types-` or `stubs-`, or ends with `-types` or `-stubs`, will default to that requirement name without the prefix/suffix. For example, `types-requests` would default to `requests`. Otherwise, will be treated like a normal requirement (see the `modules` field).

Mutually exclusive with the `modules` field.
    :param resolve: The resolve from `[python].resolves` that this requirement is included in.

If not defined, will default to `[python].default_resolve`.

When generating a lockfile for a particular resolve via the `generate-lockfiles` goal, it will include all requirements that are declared with that resolve. First-party targets like `python_source` and `pex_binary` then declare which resolve they use via their `resolve` field; so, for your first-party code to use a particular `python_requirement` target, that requirement must be included in the resolve used by that code.
    :param entry_point: Set the entry point, i.e. what gets run when executing `./my_app.pex`, to a module.

You can specify a full module like `'path.to.module'` and `'path.to.module:func'`, or use a shorthand to specify a file name, using the same syntax as the `sources` field:

  1) `'app.py'`, Pants will convert into the module `path.to.app`;
  2) `'app.py:func'`, Pants will convert into `path.to.app:func`.

You may only set one of: this field, or the `script` field, or the `executable` field. Leave off all three fields to have no entry point.
    """


def python_requirements(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    type_stubs_module_mapping: Dict[str, Iterable[str]] = FrozenDict({}),
    source: str | None = 'requirements.txt',
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    resolve: str | None = None
) -> None:
    """
    Generate a `python_requirement` for each entry in a requirements.txt-style or PEP 621 compliant `pyproject.toml` file. The choice of parser for the `source` field is determined by the file name. If the `source` field ends with `pyproject.toml`, then the file is assumed to be a PEP 621 compliant file. Any other file name uses the requirements.txt-style parser.

    Generate a `python_requirement` for each entry in a requirements.txt-style or PEP 621 compliant `pyproject.toml` file. The choice of parser for the `source` field is determined by the file name. If the `source` field ends with `pyproject.toml`, then the file is assumed to be a PEP 621 compliant file. Any other file name uses the requirements.txt-style parser.

Further details about pip-style requirements files are available from the PyPA documentation: https://pip.pypa.io/en/latest/reference/requirements-file-format/. However, pip options like `--hash` are (for now) ignored.

Pants will not follow `-r reqs.txt` lines. Instead, add a dedicated `python_requirements` target generator for that additional requirements file.

Further details about PEP 621 and `pyproject.toml` files are available from the PEP itself: https://peps.python.org/pep-0621/. If the `project.optional-dependencies` table is included, Pants will save the key/name of the optional dependency group as a tag on the generated `python_requirement`.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param module_mapping: A mapping of requirement names to a list of the modules they provide.

For example, `{"ansicolors": ["colors"]}`.

Any unspecified requirements will use a default. See the `modules` field from the `python_requirement` target for more information.
    :param type_stubs_module_mapping: A mapping of type-stub requirement names to a list of the modules they provide.

For example, `{"types-requests": ["requests"]}`.

If the requirement is not specified _and_ its name looks like a type stub, Pants will use a default. See the `type_stub_modules` field from the `python_requirement` target for more information.
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param overrides: Override the field values for generated `python_requirement` targets.

Expects a dictionary of requirements to a dictionary for the overrides. You may either use a string for a single requirement, or a string tuple for multiple requirements. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "django": {"dependencies": ["#setuptools"]},
        "ansicolors": {"description": "pretty colors"]},
        ("ansicolors, "django"): {"tags": ["overridden"]},
    }

Every overridden requirement is validated to be generated by this target.

You can specify the same requirement in multiple keys, so long as you don't override the same field more than one time for the requirement.
    :param resolve: The resolve from `[python].resolves` that this requirement is included in.

If not defined, will default to `[python].default_resolve`.

When generating a lockfile for a particular resolve via the `generate-lockfiles` goal, it will include all requirements that are declared with that resolve. First-party targets like `python_source` and `pex_binary` then declare which resolve they use via their `resolve` field; so, for your first-party code to use a particular `python_requirement` target, that requirement must be included in the resolve used by that code.
    """


def python_source(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    interpreter_constraints: Iterable[str] | None = None,
    dependencies: Iterable[str] | None = None,
    resolve: str | None = None,
    run_goal_use_sandbox: bool | None = None,
    restartable: bool = False,
    skip_mypy: bool = False,
    skip_bandit: bool = False,
    skip_flake8: bool = False,
    skip_black: bool = False,
    skip_autoflake: bool = False,
    skip_pyupgrade: bool = False,
    skip_isort: bool = False
) -> None:
    """
    A single Python source file.

    A single Python source file.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param run_goal_use_sandbox: Whether to use a sandbox when `run`ning this target. Defaults to `[python].default_run_goal_use_sandbox`.

If true, runs of this target with the `run` goal will copy the needed first-party sources into a temporary sandbox and run from there.

If false, runs of this target with the `run` goal will use the in-repo sources directly.

Note that this field only applies when running a target with the `run` goal. No other goals (such as `test`, if applicable) consult this field.

The former mode is more hermetic, and is closer to building and running the source as it were packaged in a `pex_binary`. Additionally, it may be necessary if your sources depend transitively on "generated" files which will be materialized in the sandbox in a source root, but are not in-repo.

The latter mode is similar to creating, activating, and using a virtual environment when running your files. It may also be necessary if the source being run writes files into the repo and computes their location relative to the executed files. Django's `makemigrations` command is an example of such a process.
    :param restartable: If true, runs of this target with the `run` goal may be interrupted and restarted when its input files change.
    :param skip_mypy: If true, don't run MyPy on this target's code.
    :param skip_bandit: If true, don't run Bandit on this target's code.
    :param skip_flake8: If true, don't run Flake8 on this target's code.
    :param skip_black: If true, don't run Black on this target's code.
    :param skip_autoflake: If true, don't run Autoflake on this target's code.
    :param skip_pyupgrade: If true, don't run pyupgrade on this target's code.
    :param skip_isort: If true, don't run isort on this target's code.
    """


def python_sources(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*.py', '*.pyi', '!test_*.py', '!*_test.py', '!tests.py', '!conftest.py', '!test_*.pyi', '!*_test.pyi', '!tests.pyi'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_mypy: bool = False,
    skip_bandit: bool = False,
    skip_flake8: bool = False,
    skip_black: bool = False,
    skip_autoflake: bool = False,
    skip_pyupgrade: bool = False,
    skip_isort: bool = False,
    resolve: str | None = None,
    run_goal_use_sandbox: bool | None = None,
    dependencies: Iterable[str] | None = None,
    interpreter_constraints: Iterable[str] | None = None,
    restartable: bool = False
) -> None:
    """
    Generate a `python_source` target for each file in the `sources` field.

    Generate a `python_source` target for each file in the `sources` field.

You can either use this target generator or `python_test_utils` for test utility files like `conftest.py`. They behave identically, but can help to better model and keep separate test support files vs. production files.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.py', 'new_*.py', '!old_ignore.py']`
    :param overrides: Override the field values for generated `python_source` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.py": {"skip_pylint": True]},
        "bar.py": {"skip_flake8": True]},
        ("foo.py", "bar.py"): {"tags": ["linter_disabled"]},
    }"

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `python_source` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_mypy: If true, don't run MyPy on this target's code.
    :param skip_bandit: If true, don't run Bandit on this target's code.
    :param skip_flake8: If true, don't run Flake8 on this target's code.
    :param skip_black: If true, don't run Black on this target's code.
    :param skip_autoflake: If true, don't run Autoflake on this target's code.
    :param skip_pyupgrade: If true, don't run pyupgrade on this target's code.
    :param skip_isort: If true, don't run isort on this target's code.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param run_goal_use_sandbox: Whether to use a sandbox when `run`ning this target. Defaults to `[python].default_run_goal_use_sandbox`.

If true, runs of this target with the `run` goal will copy the needed first-party sources into a temporary sandbox and run from there.

If false, runs of this target with the `run` goal will use the in-repo sources directly.

Note that this field only applies when running a target with the `run` goal. No other goals (such as `test`, if applicable) consult this field.

The former mode is more hermetic, and is closer to building and running the source as it were packaged in a `pex_binary`. Additionally, it may be necessary if your sources depend transitively on "generated" files which will be materialized in the sandbox in a source root, but are not in-repo.

The latter mode is similar to creating, activating, and using a virtual environment when running your files. It may also be necessary if the source being run writes files into the repo and computes their location relative to the executed files. Django's `makemigrations` command is an example of such a process.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param restartable: If true, runs of this target with the `run` goal may be interrupted and restarted when its input files change.
    """


def python_test(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    resolve: str | None = None,
    run_goal_use_sandbox: bool | None = None,
    timeout: int | None = None,
    xdist_concurrency: int | None = None,
    batch_compatibility_tag: str | None = None,
    runtime_package_dependencies: Iterable[str] | None = None,
    extra_env_vars: Iterable[str] | None = None,
    interpreter_constraints: Iterable[str] | None = None,
    skip_tests: bool = False,
    environment: str | None = '__local__',
    skip_mypy: bool = False,
    skip_bandit: bool = False,
    skip_flake8: bool = False,
    skip_black: bool = False,
    skip_autoflake: bool = False,
    skip_pyupgrade: bool = False,
    skip_isort: bool = False
) -> None:
    """
    A single Python test file, written in either Pytest style or unittest style.

    A single Python test file, written in either Pytest style or unittest style.

All test util code, including `conftest.py`, should go into a dedicated `python_source` target and then be included in the `dependencies` field. (You can use the `python_test_utils` target to generate these `python_source` targets.)

See https://www.pantsbuild.org/2.20/docs/python/goals/test

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param run_goal_use_sandbox: Whether to use a sandbox when `run`ning this target. Defaults to `[python].default_run_goal_use_sandbox`.

If true, runs of this target with the `run` goal will copy the needed first-party sources into a temporary sandbox and run from there.

If false, runs of this target with the `run` goal will use the in-repo sources directly.

Note that this field only applies when running a target with the `run` goal. No other goals (such as `test`, if applicable) consult this field.

The former mode is more hermetic, and is closer to building and running the source as it were packaged in a `pex_binary`. Additionally, it may be necessary if your sources depend transitively on "generated" files which will be materialized in the sandbox in a source root, but are not in-repo.

The latter mode is similar to creating, activating, and using a virtual environment when running your files. It may also be necessary if the source being run writes files into the repo and computes their location relative to the executed files. Django's `makemigrations` command is an example of such a process.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param xdist_concurrency: Maximum number of CPUs to allocate to run each test file belonging to this target.

Tests are spread across multiple CPUs using `pytest-xdist` (https://pytest-xdist.readthedocs.io/en/latest/index.html). Use of `pytest-xdist` must be enabled using the `[pytest].xdist_enabled` option for this field to have an effect.

If `pytest-xdist` is enabled and this field is unset, Pants will attempt to derive the concurrency for test sources by counting the number of tests in each file.

Set this field to `0` to explicitly disable use of `pytest-xdist` for a target.
    :param batch_compatibility_tag: An arbitrary value used to mark the test files belonging to this target as valid for batched execution.

It's _sometimes_ safe to run multiple `python_test`s within a single test runner process, and doing so can give significant wins by allowing reuse of expensive test setup / teardown logic. To opt into this behavior, set this field to an arbitrary non-empty string on all the `python_test` targets that are safe/compatible to run in the same process.

If this field is left unset on a target, the target is assumed to be incompatible with all others and will run in a dedicated `pytest` process.

If this field is set on a target, and its value is different from the value on some other test `python_test`, then the two targets are explicitly incompatible and are guaranteed to not run in the same `pytest` process.

If this field is set on a target, and its value is the same as the value on some other `python_test`, then the two targets are explicitly compatible and _may_ run in the same test runner process. Compatible tests may not end up in the same test runner batch if:

  * There are "too many" compatible tests in a partition, as determined by the `[test].batch_size` config parameter, or
  * Compatible tests have some incompatibility in Pants metadata (i.e. different `resolve`s or `extra_env_vars`).

When tests with the same `batch_compatibility_tag` have incompatibilities in some other Pants metadata, they will be automatically split into separate batches. This way you can set a high-level `batch_compatibility_tag` using `__defaults__` and then have tests continue to work as you tweak BUILD metadata on specific targets.
    :param runtime_package_dependencies: Addresses to targets that can be built with the `pants package` goal and whose resulting artifacts should be included in the test run.

Pants will build the artifacts as if you had run `pants package`. It will include the results in your test's chroot, using the same name they would normally have, but without the `--distdir` prefix (e.g. `dist/`).

You can include anything that can be built by `pants package`, e.g. a `pex_binary`, `python_aws_lambda_function`, or an `archive`.
    :param extra_env_vars: Additional environment variables to include in test processes.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.

This will be merged with and override values from `[test].extra_env_vars`.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param skip_tests: If true, don't run this target's tests.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    :param skip_mypy: If true, don't run MyPy on this target's code.
    :param skip_bandit: If true, don't run Bandit on this target's code.
    :param skip_flake8: If true, don't run Flake8 on this target's code.
    :param skip_black: If true, don't run Black on this target's code.
    :param skip_autoflake: If true, don't run Autoflake on this target's code.
    :param skip_pyupgrade: If true, don't run pyupgrade on this target's code.
    :param skip_isort: If true, don't run isort on this target's code.
    """


def python_test_utils(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('conftest.py', 'test_*.pyi', '*_test.pyi', 'tests.pyi'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_mypy: bool = False,
    skip_bandit: bool = False,
    skip_flake8: bool = False,
    skip_black: bool = False,
    skip_autoflake: bool = False,
    skip_pyupgrade: bool = False,
    skip_isort: bool = False,
    resolve: str | None = None,
    run_goal_use_sandbox: bool | None = None,
    dependencies: Iterable[str] | None = None,
    interpreter_constraints: Iterable[str] | None = None
) -> None:
    """
    Generate a `python_source` target for each file in the `sources` field.

    Generate a `python_source` target for each file in the `sources` field.

This target generator is intended for test utility files like `conftest.py` or `my_test_utils.py`. Technically, it generates `python_source` targets in the exact same way as the `python_sources` target generator does, only that the `sources` field has a different default. So it is valid to use `python_sources` instead. However, this target can be helpful to better model your code by keeping separate test support files vs. production files.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['conftest.py', 'test_*.pyi', '*_test.pyi', 'tests.pyi']`
    :param overrides: Override the field values for generated `python_source` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.py": {"skip_pylint": True]},
        "bar.py": {"skip_flake8": True]},
        ("foo.py", "bar.py"): {"tags": ["linter_disabled"]},
    }"

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `python_source` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_mypy: If true, don't run MyPy on this target's code.
    :param skip_bandit: If true, don't run Bandit on this target's code.
    :param skip_flake8: If true, don't run Flake8 on this target's code.
    :param skip_black: If true, don't run Black on this target's code.
    :param skip_autoflake: If true, don't run Autoflake on this target's code.
    :param skip_pyupgrade: If true, don't run pyupgrade on this target's code.
    :param skip_isort: If true, don't run isort on this target's code.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param run_goal_use_sandbox: Whether to use a sandbox when `run`ning this target. Defaults to `[python].default_run_goal_use_sandbox`.

If true, runs of this target with the `run` goal will copy the needed first-party sources into a temporary sandbox and run from there.

If false, runs of this target with the `run` goal will use the in-repo sources directly.

Note that this field only applies when running a target with the `run` goal. No other goals (such as `test`, if applicable) consult this field.

The former mode is more hermetic, and is closer to building and running the source as it were packaged in a `pex_binary`. Additionally, it may be necessary if your sources depend transitively on "generated" files which will be materialized in the sandbox in a source root, but are not in-repo.

The latter mode is similar to creating, activating, and using a virtual environment when running your files. It may also be necessary if the source being run writes files into the repo and computes their location relative to the executed files. Django's `makemigrations` command is an example of such a process.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    """


def python_tests(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('test_*.py', '*_test.py', 'tests.py'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_mypy: bool = False,
    skip_bandit: bool = False,
    skip_flake8: bool = False,
    skip_black: bool = False,
    skip_autoflake: bool = False,
    skip_pyupgrade: bool = False,
    skip_isort: bool = False,
    dependencies: Iterable[str] | None = None,
    resolve: str | None = None,
    run_goal_use_sandbox: bool | None = None,
    timeout: int | None = None,
    xdist_concurrency: int | None = None,
    batch_compatibility_tag: str | None = None,
    runtime_package_dependencies: Iterable[str] | None = None,
    extra_env_vars: Iterable[str] | None = None,
    interpreter_constraints: Iterable[str] | None = None,
    skip_tests: bool = False,
    environment: str | None = '__local__'
) -> None:
    """
    Generate a `python_test` target for each file in the `sources` field.

    Generate a `python_test` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['test_*.py', '*_test.py', 'tests.py']`
    :param overrides: Override the field values for generated `python_test` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo_test.py": {"timeout": 120},
        "bar_test.py": {"timeout": 200},
        ("foo_test.py", "bar_test.py"): {"tags": ["slow_tests"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `python_test` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_mypy: If true, don't run MyPy on this target's code.
    :param skip_bandit: If true, don't run Bandit on this target's code.
    :param skip_flake8: If true, don't run Flake8 on this target's code.
    :param skip_black: If true, don't run Black on this target's code.
    :param skip_autoflake: If true, don't run Autoflake on this target's code.
    :param skip_pyupgrade: If true, don't run pyupgrade on this target's code.
    :param skip_isort: If true, don't run isort on this target's code.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    :param run_goal_use_sandbox: Whether to use a sandbox when `run`ning this target. Defaults to `[python].default_run_goal_use_sandbox`.

If true, runs of this target with the `run` goal will copy the needed first-party sources into a temporary sandbox and run from there.

If false, runs of this target with the `run` goal will use the in-repo sources directly.

Note that this field only applies when running a target with the `run` goal. No other goals (such as `test`, if applicable) consult this field.

The former mode is more hermetic, and is closer to building and running the source as it were packaged in a `pex_binary`. Additionally, it may be necessary if your sources depend transitively on "generated" files which will be materialized in the sandbox in a source root, but are not in-repo.

The latter mode is similar to creating, activating, and using a virtual environment when running your files. It may also be necessary if the source being run writes files into the repo and computes their location relative to the executed files. Django's `makemigrations` command is an example of such a process.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param xdist_concurrency: Maximum number of CPUs to allocate to run each test file belonging to this target.

Tests are spread across multiple CPUs using `pytest-xdist` (https://pytest-xdist.readthedocs.io/en/latest/index.html). Use of `pytest-xdist` must be enabled using the `[pytest].xdist_enabled` option for this field to have an effect.

If `pytest-xdist` is enabled and this field is unset, Pants will attempt to derive the concurrency for test sources by counting the number of tests in each file.

Set this field to `0` to explicitly disable use of `pytest-xdist` for a target.
    :param batch_compatibility_tag: An arbitrary value used to mark the test files belonging to this target as valid for batched execution.

It's _sometimes_ safe to run multiple `python_test`s within a single test runner process, and doing so can give significant wins by allowing reuse of expensive test setup / teardown logic. To opt into this behavior, set this field to an arbitrary non-empty string on all the `python_test` targets that are safe/compatible to run in the same process.

If this field is left unset on a target, the target is assumed to be incompatible with all others and will run in a dedicated `pytest` process.

If this field is set on a target, and its value is different from the value on some other test `python_test`, then the two targets are explicitly incompatible and are guaranteed to not run in the same `pytest` process.

If this field is set on a target, and its value is the same as the value on some other `python_test`, then the two targets are explicitly compatible and _may_ run in the same test runner process. Compatible tests may not end up in the same test runner batch if:

  * There are "too many" compatible tests in a partition, as determined by the `[test].batch_size` config parameter, or
  * Compatible tests have some incompatibility in Pants metadata (i.e. different `resolve`s or `extra_env_vars`).

When tests with the same `batch_compatibility_tag` have incompatibilities in some other Pants metadata, they will be automatically split into separate batches. This way you can set a high-level `batch_compatibility_tag` using `__defaults__` and then have tests continue to work as you tweak BUILD metadata on specific targets.
    :param runtime_package_dependencies: Addresses to targets that can be built with the `pants package` goal and whose resulting artifacts should be included in the test run.

Pants will build the artifacts as if you had run `pants package`. It will include the results in your test's chroot, using the same name they would normally have, but without the `--distdir` prefix (e.g. `dist/`).

You can include anything that can be built by `pants package`, e.g. a `pex_binary`, `python_aws_lambda_function`, or an `archive`.
    :param extra_env_vars: Additional environment variables to include in test processes.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.

This will be merged with and override values from `[test].extra_env_vars`.
    :param interpreter_constraints: The Python interpreters this code is compatible with.

Each element should be written in pip-style format, e.g. `CPython==2.7.*` or `CPython>=3.6,<4`. You can leave off `CPython` as a shorthand, e.g. `>=2.7` will be expanded to `CPython>=2.7`.

Specify more than one element to OR the constraints, e.g. `['PyPy==3.7.*', 'CPython==3.7.*']` means either PyPy 3.7 _or_ CPython 3.7.

If the field is not set, it will default to the option `[python].interpreter_constraints`.

See https://www.pantsbuild.org/2.20/docs/python/overview/interpreter-compatibility for how these interpreter constraints are merged with the constraints of dependencies.
    :param skip_tests: If true, don't run this target's tests.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    """


def relocated_files(
    name: str,
    files_targets: Iterable[str],
    src: str,
    dest: str,
    tags: Iterable[str] | None = None,
    description: str | None = None
) -> None:
    """
    Loose files with path manipulation applied.

    Loose files with path manipulation applied.

Allows you to relocate the files at runtime to something more convenient than their actual paths in your project.

For example, you can relocate `src/resources/project1/data.json` to instead be `resources/data.json`. Your other target types can then add this target to their `dependencies` field, rather than using the original `files` target.

To remove a prefix:

    # Results in `data.json`.
    relocated_files(
        files_targets=["src/resources/project1:target"],
        src="src/resources/project1",
        dest="",
    )

To add a prefix:

    # Results in `images/logo.svg`.
    relocated_files(
        files_targets=["//:logo"],
        src="",
        dest="images",
    )

To replace a prefix:

    # Results in `new_prefix/project1/data.json`.
    relocated_files(
        files_targets=["src/resources/project1:target"],
        src="src/resources",
        dest="new_prefix",
    )

    :param name: The name of the target
    :param files_targets: Addresses to the original `file` and `files` targets that you want to relocate, such as `['//:json_files']`.

Every target will be relocated using the same mapping. This means that every target must include the value from the `src` field in their original path.
    :param src: The original prefix that you want to replace, such as `src/resources`.

You can set this field to the empty string to preserve the original path; the value in the `dest` field will then be added to the beginning of this original path.
    :param dest: The new prefix that you want to add to the beginning of the path, such as `data`.

You can set this field to the empty string to avoid adding any new values to the path; the value in the `src` field will then be stripped, rather than replaced.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    """


def remote_environment(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    platform: 'linux_arm64' | 'linux_x86_64' | 'macos_arm64' | 'macos_x86_64' | None = 'linux_x86_64',
    extra_platform_properties: Iterable[str] | None = (),
    fallback_environment: str | None = None,
    cache_binary_discovery: bool = False,
    python_bootstrap_names: Iterable[str] | None = None,
    python_native_code_ld_flags: Iterable[str] | None = None,
    python_bootstrap_search_path: Iterable[str] | None = None,
    python_native_code_cpp_flags: Iterable[str] | None = None,
    pex_executable_search_paths: Iterable[str] | None = None,
    nodejs_corepack_env_vars: Iterable[str] | None = None,
    nodejs_search_path: Iterable[str] | None = None,
    shell_setup_executable_search_paths: Iterable[str] | None = None,
    subprocess_environment_env_vars: Iterable[str] | None = None,
    test_extra_env_vars: Iterable[str] | None = None,
    nodejs_executable_search_paths: Iterable[str] | None = None,
    system_binaries_system_binary_paths: Iterable[str] | None = None
) -> None:
    """
    Configuration of a remote execution environment used for building your code.

    Configuration of a remote execution environment used for building your code.

Environment configuration includes platform properties and a fallback environment, as well as environment-aware options (such as environment variables and search paths) used by Pants to execute processes in this remote environment.

Note that you must also configure remote execution with the global options like `remote_execution` and `remote_execution_address`.

To use this environment, map this target's address with a memorable name in `[environments-preview].names`. You can then consume this environment by specifying the name in the `environment` field defined on other targets.

Often, it is only necessary to have a single `remote_environment` target for your repository, but it can be useful to have >1 so that you can set different `extra_platform_properties`. For example, with some servers, you could use this to configure a different Docker image per environment.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param platform: The platform used by the remote execution environment.
    :param extra_platform_properties: Platform properties to set on remote execution requests.

Format: `property=value`. Multiple values should be specified as multiple occurrences of this flag.

Pants itself may add additional platform properties.
    :param fallback_environment: The environment to fallback to when remote execution is disabled via the global option `--remote-execution`.

Must be an environment name from the option `[environments-preview].names`, the special string `__local__` to use the relevant local environment, or the Python value `None` to error when remote execution is disabled.

Tip: if you are using a Docker image with your remote execution environment (usually enabled by setting the field `extra_platform_properties`), then it can be useful to fallback to an equivalent `docker_image` target so that you have a consistent execution environment.
    :param cache_binary_discovery: If true, will cache system binary discovery, e.g. finding Python interpreters.

When safe to do, it is preferable to set this option to `True` for faster performance by avoiding wasted work. Otherwise, Pants will search for system binaries whenever the Pants daemon is restarted.

However, it is only safe to set this to `True` if the remote execution environment has a stable environment, e.g. the server will not change versions of installed system binaries. Otherwise, you risk caching results that become stale when the server changes its environment, which may break your builds. With some remote execution servers, you can specify a Docker image to run with via the field `extra_platform_properties`; if you are able to specify what Docker image to use, and also use a pinned tag of the image, it is likely safe to set this field to true.
    :param python_bootstrap_names: Overrides the default value from the option `[python-bootstrap].names` when this environment target is active.
    :param python_native_code_ld_flags: Overrides the default value from the option `[python-native-code].ld_flags` when this environment target is active.
    :param python_bootstrap_search_path: Overrides the default value from the option `[python-bootstrap].search_path` when this environment target is active.
    :param python_native_code_cpp_flags: Overrides the default value from the option `[python-native-code].cpp_flags` when this environment target is active.
    :param pex_executable_search_paths: Overrides the default value from the option `[pex].executable_search_paths` when this environment target is active.
    :param nodejs_corepack_env_vars: Overrides the default value from the option `[nodejs].corepack_env_vars` when this environment target is active.
    :param nodejs_search_path: Overrides the default value from the option `[nodejs].search_path` when this environment target is active.
    :param shell_setup_executable_search_paths: Overrides the default value from the option `[shell-setup].executable_search_paths` when this environment target is active.
    :param subprocess_environment_env_vars: Overrides the default value from the option `[subprocess-environment].env_vars` when this environment target is active.
    :param test_extra_env_vars: Overrides the default value from the option `[test].extra_env_vars` when this environment target is active.
    :param nodejs_executable_search_paths: Overrides the default value from the option `[nodejs].executable_search_paths` when this environment target is active.
    :param system_binaries_system_binary_paths: Overrides the default value from the option `[system-binaries].system_binary_paths` when this environment target is active.
    """


def resource(
    name: str,
    source: str | http_source | pants.core.target_types.per_platform[pants.core.target_types.http_source],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A single resource file embedded in a code package and accessed in a location-independent manner.

    A single resource file embedded in a code package and accessed in a location-independent manner.

Resources are embedded in code artifacts such as Python wheels or JVM JARs. The sources of a `resources` target are accessed via language-specific resource APIs, such as Python's `pkgutil` or JVM's ClassLoader, via paths relative to the target's source root.

    :param name: The name of the target
    :param source: The source of this target.

If a string is provided, represents a path that is relative to the BUILD file's directory, e.g. `source='example.ext'`.

If an `http_source` is provided, represents the network location to download the source from. The downloaded file will exist in the sandbox in the same directory as the target.

`http_source` has the following signature:

    http_source(url: str, *, len: int, sha256: str, filename: str = "")

The filename defaults to the last part of the URL path (e.g. `example.ext`), but can also be specified if you wish to have control over the file name. You cannot, however, specify a path separator to download the file into a subdirectory (you must declare a target in desired subdirectory).

You can easily get the len and checksum with the following command:

    curl -L $URL | tee >(wc -c) >(shasum -a 256) >/dev/null

If a `per_platform` is provided, represents a mapping from platform to `http_source`, where the platform is one of (`linux_arm64`, `linux_x86_64`, `macos_arm64`, `macos_x86_64`) and is resolved in the execution target. Each `http_source` value MUST have the same filename provided.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def resources(
    name: str,
    sources: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `resource` target for each file in the `sources` field.

    Generate a `resource` target for each file in the `sources` field.

    :param name: The name of the target
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.txt', 'new_*.md', '!old_ignore.csv']`
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param overrides: Override the field values for generated `resource` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.json": {"description": "our customer model"]},
        "bar.json": {"description": "our product model"]},
        ("foo.json", "bar.json"): {"tags": ["overridden"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `resource` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def run_shell_command(
    name: str,
    command: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    execution_dependencies: Iterable[str] | None = None,
    runnable_dependencies: Iterable[str] | None = None,
    workdir: str | None = '.'
) -> None:
    """
    Run a script in the workspace, with all dependencies packaged/copied into a chroot.

    Run a script in the workspace, with all dependencies packaged/copied into a chroot.

Example BUILD file:

    run_shell_command(
        command="./scripts/my-script.sh --data-files-dir={chroot}",
        execution_dependencies=["src/project/files:data"],
    )

The `command` may use either `{chroot}` on the command line, or the `$CHROOT` environment variable to get the root directory for where any dependencies are located.

In contrast to the `shell_command`, in addition to `workdir` you only have the `command` and `execution_dependencies` fields as the `tools` you are going to use are already on the PATH which is inherited from the Pants environment. Also, the `outputs` does not apply, as any output files produced will end up directly in your project tree.

    :param name: The name of the target
    :param command: Shell command to execute.

The command is executed as `'bash -c <command>'` by default. If you want to invoke a binary use `exec -a $0 <binary> <args>` as the command so that the binary gets the correct `argv[0]` set.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param execution_dependencies: The execution dependencies for this command.

Dependencies specified here are those required to make the command complete successfully (e.g. file inputs, packages compiled from other targets, etc), but NOT required to make the outputs of the command useful.

See also `runnable_dependencies`.
    :param runnable_dependencies: The runnable dependencies for this command.

Dependencies specified here are those required to exist on the `PATH` to make the command complete successfully (interpreters specified in a `#!` command, etc). Note that these dependencies will be made available on the `PATH` with the name of the target.

See also `execution_dependencies`.
    :param workdir: Sets the working directory for the process.

Values are relative to the build root, except in the following cases:

* `.` specifies the location of the `BUILD` file.
* Values beginning with `./` are relative to the location of the `BUILD` file.
* `/` or the empty string specifies the build root.
* Values beginning with `/` are also relative to the build root.
    """


def scie_binary(
    name: str,
    dependencies: Iterable[str],
    tags: Iterable[str] | None = None,
    description: str | None = None,
    binary_name: str | None = None,
    platforms: Iterable[str] | None = None,
    lift: str | None = None
) -> None:
    """
    A single-file Python executable with a Python interpreter embedded, built via scie-jump.

    A single-file Python executable with a Python interpreter embedded, built via scie-jump.

To use this target, first create a `pex_binary` target with the code you want included in your binary, per {doc_url('pex-files')}. Then add this `pex_binary` target to the `dependencies` field. See the `help` for `dependencies` for more information.

    :param name: The name of the target
    :param dependencies: The address of a single `pex_binary` target to include in the binary, e.g. `['src/python/project:pex']`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param binary_name: The name of the binary that will be output by `scie-jump`. If not set, this will default to the name of this target.
    :param platforms: A field to indicate what what platform(s) to build for.

The default selection is `None`, in which case we will default to the current platform. Possible values are: `linux-aarch64`, `linux-x86_64`, `macos-aarch64`, `macos-x86_64`.
    :param lift: If set, the specified toml file will be used to configure the `scie` and all other fields will be ignored.

The path is relative to the BUILD file's directory and it must end in a `.toml` extension.

Example:
    lift = "helloworldlift.toml"

Inside the toml, strings that are prefixed with `:` will be interpreted as references to other targets. For example, `:mypex` will be interpreted as a reference to the `mypex` target in the same BUILD file and the Lift file will be updated to include the `mypex` location.

Example: [[lift.files]]
    name = ":helloworld-pex"
    """


def shell_command(
    name: str,
    command: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    output_dependencies: Iterable[str] | None = None,
    execution_dependencies: Iterable[str] | None = None,
    runnable_dependencies: Iterable[str] | None = None,
    log_output: bool = False,
    output_files: Iterable[str] | None = (),
    output_directories: Iterable[str] | None = (),
    timeout: int | None = 30,
    tools: Iterable[str] | None = (),
    extra_env_vars: Iterable[str] | None = None,
    workdir: str | None = '.',
    experimental_named_caches: Dict[str, str] | None = None,
    root_output_directory: str | None = '/',
    environment: str | None = '__local__'
) -> None:
    """
    Execute any external tool for its side effects.

    Execute any external tool for its side effects.

Example BUILD file:

    shell_command(
        command="./my-script.sh --flag",
        tools=["tar", "curl", "cat", "bash", "env"],
        execution_dependencies=[":scripts"],
        output_files=["logs/my-script.log"],
        output_directories=["results"],
    )

    shell_sources(name="scripts")

Remember to add this target to the dependencies of each consumer, such as your `python_tests` or `docker_image`. When relevant, Pants will run your `command` and insert the `outputs` into that consumer's context.

The command may be retried and/or cancelled, so ensure that it is idempotent.

    :param name: The name of the target
    :param command: Shell command to execute.

The command is executed as `'bash -c <command>'` by default. If you want to invoke a binary use `exec -a $0 <binary> <args>` as the command so that the binary gets the correct `argv[0]` set.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param output_dependencies: Any dependencies that need to be present (as transitive dependencies) whenever the outputs of this target are consumed (including as dependencies).

See also `execution_dependencies` and `runnable_dependencies`.
    :param execution_dependencies: The execution dependencies for this command.

Dependencies specified here are those required to make the command complete successfully (e.g. file inputs, packages compiled from other targets, etc), but NOT required to make the outputs of the command useful. Dependencies that are required to use the outputs produced by this command should be specified using the `output_dependencies` field.

If this field is specified, dependencies from `output_dependencies` will not be added to the execution sandbox.

See also `output_dependencies` and `runnable_dependencies`.
    :param runnable_dependencies: The runnable dependencies for this command.

Dependencies specified here are those required to exist on the `PATH` to make the command complete successfully (interpreters specified in a `#!` command, etc). Note that these dependencies will be made available on the `PATH` with the name of the target.

See also `output_dependencies` and `execution_dependencies`.
    :param log_output: Set to true if you want the output logged to the console.
    :param output_files: Specify the output files to capture, relative to the value of `workdir`.

For directories, use `output_directories`. At least one of `output_files` and`output_directories` must be specified.

Relative paths (including `..`) may be used, as long as the path does not ascend further than the build root.
    :param output_directories: Specify full directories (including recursive descendants) of output to capture, relative to the value of `workdir`.

For individual files, use `output_files`. At least one of `output_files` and`output_directories` must be specified.

Relative paths (including `..`) may be used, as long as the path does not ascend further than the build root.
    :param timeout: Command execution timeout (in seconds).
    :param tools: Specify required executable tools that might be used.

Only the tools explicitly provided will be available on the search PATH, and these tools must be found on the paths provided by `[shell-setup].executable_search_paths` (which defaults to the system PATH).
    :param extra_env_vars: Additional environment variables to provide to the process.

Entries are strings in the form `ENV_VAR=value` to use explicitly; or just `ENV_VAR` to copy the value of a variable in Pants's own environment.
    :param workdir: Sets the working directory for the process.

Values are relative to the build root, except in the following cases:

* `.` specifies the location of the `BUILD` file.
* Values beginning with `./` are relative to the location of the `BUILD` file.
* `/` or the empty string specifies the build root.
* Values beginning with `/` are also relative to the build root.
    :param experimental_named_caches: Named caches to construct for the execution. See https://www.pantsbuild.org/docs/reference-global#named_caches_dir.

The keys of the mapping are the directory name to be created in the named caches dir. The values are the name of the symlink (relative to the sandbox root) in the sandbox which points to the subdirectory in the named caches dir

NOTE: The named caches MUST be handled with great care. Processes accessing the named caches can be run in parallel, and can be cancelled at any point in their execution (and potentially restarted). That means that _every_ operation modifying the contents of the cache MUST be concurrency and cancellation safe.
    :param root_output_directory: Adjusts the location of files output by this target, when consumed as a dependency.

Values are relative to the build root, except in the following cases:

  * `.` specifies the location of the `BUILD` file.
  * Values beginning with `./` are relative to the location of the `BUILD` file.
  * `/` or the empty string specifies the build root.
  * Values beginning with `/` are also relative to the build root.
    :param environment: Specify which environment target to consume environment-sensitive options from.

Once environments are defined in `[environments-preview].names`, you can specify the environment for this target by its name. Any fields that are defined in that environment will override the values from options set by `pants.toml`, command line values, or environment variables.

You can specify multiple valid environments by using `parametrize`. If `__local__` is specified, Pants will fall back to the `local_environment` defined for the current platform, or no environment if no such environment exists.
    """


def shell_source(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    skip_shellcheck: bool = False,
    skip_shfmt: bool = False
) -> None:
    """
    A single Bourne-based shell script, e.g. a Bash script.

    A single Bourne-based shell script, e.g. a Bash script.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param skip_shellcheck: If true, don't run Shellcheck on this target's code.
    :param skip_shfmt: If true, don't run shfmt on this target's code.
    """


def shell_sources(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*.sh', '!*_test.sh', '!test_*.sh', '!tests.sh'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_shellcheck: bool = False,
    skip_shfmt: bool = False,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `shell_source` target for each file in the `sources` field.

    Generate a `shell_source` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['example.sh', 'new_*.sh', '!old_ignore.sh']`
    :param overrides: Override the field values for generated `shell_source` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo.sh": {"skip_shellcheck": True]},
        "bar.sh": {"skip_shfmt": True]},
        ("foo.sh", "bar.sh"): {"tags": ["linter_disabled"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `shell_source` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_shellcheck: If true, don't run Shellcheck on this target's code.
    :param skip_shfmt: If true, don't run shfmt on this target's code.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def shunit2_test(
    name: str,
    source: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None,
    timeout: int | None = None,
    skip_tests: bool = False,
    shell: 'bash' | 'dash' | 'ksh' | 'pdksh' | 'sh' | 'zsh' | None = None,
    runtime_package_dependencies: Iterable[str] | None = None,
    skip_shellcheck: bool = False,
    skip_shfmt: bool = False
) -> None:
    """
    A single test file for Bourne-based shell scripts using the shunit2 test framework.

    A single test file for Bourne-based shell scripts using the shunit2 test framework.

To use, add tests to your file per https://github.com/kward/shunit2/. Specify the shell to run with by either setting the field `shell` or including a shebang. To test the same file with multiple shells, create multiple `shunit2_tests` targets, one for each shell.

Pants will automatically download the `shunit2` bash script and add `source ./shunit2` to your test for you. If you already have `source ./shunit2`, Pants will overwrite it to use the correct relative path.

    :param name: The name of the target
    :param source: A single file that belongs to this target.

Path is relative to the BUILD file's directory, e.g. `source='example.ext'`.
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param skip_tests: If true, don't run this target's tests.
    :param shell: Which shell to run the tests with. If unspecified, Pants will look for a shebang line.
    :param runtime_package_dependencies: Addresses to targets that can be built with the `pants package` goal and whose resulting artifacts should be included in the test run.

Pants will build the artifacts as if you had run `pants package`. It will include the results in your test's chroot, using the same name they would normally have, but without the `--distdir` prefix (e.g. `dist/`).

You can include anything that can be built by `pants package`, e.g. a `pex_binary`, `python_aws_lambda_function`, or an `archive`.
    :param skip_shellcheck: If true, don't run Shellcheck on this target's code.
    :param skip_shfmt: If true, don't run shfmt on this target's code.
    """


def shunit2_tests(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    sources: Iterable[str] | None = ('*_test.sh', 'test_*.sh', 'tests.sh'),
    overrides: Dict[Union[str, Tuple[str, ...]], Dict[str, Any]] | None = None,
    skip_shellcheck: bool = False,
    skip_shfmt: bool = False,
    dependencies: Iterable[str] | None = None,
    timeout: int | None = None,
    skip_tests: bool = False,
    shell: 'bash' | 'dash' | 'ksh' | 'pdksh' | 'sh' | 'zsh' | None = None,
    runtime_package_dependencies: Iterable[str] | None = None
) -> None:
    """
    Generate a `shunit2_test` target for each file in the `sources` field.

    Generate a `shunit2_test` target for each file in the `sources` field.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param sources: A list of files and globs that belong to this target.

Paths are relative to the BUILD file's directory. You can ignore files/globs by prefixing them with `!`.

Example: `sources=['test.sh', 'test_*.sh', '!test_ignore.sh']`
    :param overrides: Override the field values for generated `shunit2_test` targets.

Expects a dictionary of relative file paths and globs to a dictionary for the overrides. You may either use a string for a single path / glob, or a string tuple for multiple paths / globs. Each override is a dictionary of field names to the overridden value.

For example:

    overrides={
        "foo_test.sh": {"timeout": 120},
        "bar_test.sh": {"timeout": 200},
        ("foo_test.sh", "bar_test.sh"): {"tags": ["slow_tests"]},
    }

File paths and globs are relative to the BUILD file's directory. Every overridden file is validated to belong to this target's `sources` field.

If you'd like to override a field's value for every `shunit2_test` target generated by this target, change the field directly on this target rather than using the `overrides` field.

You can specify the same file name in multiple keys, so long as you don't override the same field more than one time for the file.
    :param skip_shellcheck: If true, don't run Shellcheck on this target's code.
    :param skip_shfmt: If true, don't run shfmt on this target's code.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    :param timeout: A timeout (in seconds) used by each test file belonging to this target.

If unset, will default to `[test].timeout_default`; if that option is also unset, then the test will never time out. Will never exceed `[test].timeout_maximum`. Only applies if the option `--test-timeouts` is set to true (the default).
    :param skip_tests: If true, don't run this target's tests.
    :param shell: Which shell to run the tests with. If unspecified, Pants will look for a shebang line.
    :param runtime_package_dependencies: Addresses to targets that can be built with the `pants package` goal and whose resulting artifacts should be included in the test run.

Pants will build the artifacts as if you had run `pants package`. It will include the results in your test's chroot, using the same name they would normally have, but without the `--distdir` prefix (e.g. `dist/`).

You can include anything that can be built by `pants package`, e.g. a `pex_binary`, `python_aws_lambda_function`, or an `archive`.
    """


def target(
    name: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    dependencies: Iterable[str] | None = None
) -> None:
    """
    A generic target with no specific type.

    A generic target with no specific type.

This can be used as a generic "bag of dependencies", i.e. you can group several different targets into one single target so that your other targets only need to depend on one thing.

    :param name: The name of the target
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param dependencies: Addresses to other targets that this target depends on, e.g. `['helloworld/subdir:lib', 'helloworld/main.py:lib', '3rdparty:reqs#django']`.

This augments any dependencies inferred by Pants, such as by analyzing your imports. Use `pants dependencies` or `pants peek` on this target to get the final result.

See https://www.pantsbuild.org/2.20/docs/using-pants/key-concepts/targets-and-build-files for more about how addresses are formed, including for generated targets. You can also run `pants list ::` to find all addresses in your project, or `pants list dir` to find all addresses defined in that directory.

If the target is in the same BUILD file, you can leave off the BUILD file path, e.g. `:tgt` instead of `helloworld/subdir:tgt`. For generated first-party addresses, use `./` for the file path, e.g. `./main.py:tgt`; for all other generated targets, use `:tgt#generated_name`.

You may exclude dependencies by prefixing with `!`, e.g. `['!helloworld/subdir:lib', '!./sibling.txt']`. Ignores are intended for false positives with dependency inference; otherwise, simply leave off the dependency from the BUILD file.
    """


def vcs_version(
    name: str,
    generate_to: str,
    template: str,
    tags: Iterable[str] | None = None,
    description: str | None = None,
    tag_regex: str | None = '^(?:[\\w-]+-)?(?P<version>[vV]?\\d+(?:\\.\\d+){0,2}[^\\+]*)(?:\\+.*)?$',
    version_scheme: str | None = None,
    local_scheme: str | None = None,
    python_resolve: str | None = None
) -> None:
    """
    Generates a version string from VCS state.

    Generates a version string from VCS state.

Uses a constrained but useful subset of the full functionality of setuptools_scm (https://github.com/pypa/setuptools_scm). These constraints avoid pitfalls in the interaction of setuptools_scm with Pants's hermetic environments.

In particular, we ignore any existing setuptools_scm config. Instead you must provide a subset of that config in this target's fields.

If you need functionality that is not currently exposed here, please reach out to us at https://www.pantsbuild.org/community/getting-help.

    :param name: The name of the target
    :param generate_to: Generate the version data to this relative path, using the template field.

Note that the generated output will not be written to disk in the source tree, but will be available as a generated dependency to code that depends on this target.
    :param template: Generate the version data using this format string, which takes a version format kwarg.

E.g., `'version = "{version}"'`
    :param tags: Arbitrary strings to describe a target.

For example, you may tag some test targets with 'integration_test' so that you could run `pants --tag='integration_test' test ::` to only run on targets with that tag.
    :param description: A human-readable description of the target.

Use `pants list --documented ::` to see all targets with descriptions.
    :param tag_regex: A Python regex string to extract the version string from a VCS tag.

The regex needs to contain either a single match group, or a group named version, that captures the actual version information.

Note that this is unrelated to the tags field and Pants's own tags concept.

See https://github.com/pypa/setuptools_scm for implementation details.
    :param version_scheme: The version scheme to configure `setuptools_scm` to use. See https://setuptools-scm.readthedocs.io/en/latest/extending/#available-implementations
    :param local_scheme: The local scheme to configure `setuptools_scm` to use. See https://setuptools-scm.readthedocs.io/en/latest/extending/#available-implementations_1
    :param python_resolve: The resolve from `[python].resolves` to use.

If not defined, will default to `[python].default_resolve`.

All dependencies must share the same value for their `resolve` field.
    """

